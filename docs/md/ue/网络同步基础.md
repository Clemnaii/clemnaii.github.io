# 网络同步基础

---

> 以下内容基于UE4

服务器维护着游戏场景中的所有对象（角色、物品、环境等等），每个客户端都会对这些对象进行一个拷贝，服务器会实时将对象的新状态通过`bReplicates`同步机制更新每个客户端的对象的状态**（真实状态-->本地状态）**；当客户端需要更新某个对象时（前提它具有对这个对象的控制权），客户端会通过`RPC`访问服务器，令服务器在服务器端更新该对象的状态，服务器再把新状态通知各个客户端进行更新**（本地状态-->真实状态-->本地状态）**。

---

## 一、同步的流程

1. **服务端是权威（Authority）**，
    所有的 `Actor`、`组件` 的真正状态都只在服务端维护一份“真实数据”。

2. **客户端看到的是这些 Actor 的“副本”**，
    这些副本通过 **`bReplicates = true`** 实现的网络同步，从服务端发过来。

3. **这些复制是“只读的”副本**（默认情况下）：

   - 客户端不能直接修改复制来的 Actor 状态。
   - 你在客户端修改变量并不会反馈回服务器。

4. **只有“拥有控制权”的客户端可以发 RPC 指令**（比如按键让角色移动）：

   - 客户端不能直接改 Actor，只能通过 **`UFUNCTION(Server)`** 的方式告诉服务器：**我要让某个 Actor 做某事**。
   - 服务端执行完这个行为后，会通过 `Replicated` 或 `Multicast` 同步给其他客户端。

5. 所以：

   > 客户端不是真的“控制”了 Actor，只是通过 **RPC 向服务端提出“请求”**，
   >  然后服务端改数据、处理逻辑，再把结果同步给客户端。

---

## 二、举例

你按了“开火”：

- **客户端操作**：

  ```clike
  MyCharacter->ServerFire(); // 调用一个RPC: UFUNCTION(Server, Reliable)
  ```

- **服务端响应**：

  ```clike
  void AMyCharacter::ServerFire_Implementation()
  {
      SpawnProjectile();
      // 然后可能再用 Multicast 通知所有客户端播放开火动画
      ...
  }
  ```

- **客户端接收到服务端发来的更新**，比如新的子弹、角色姿态等。

<br>

**📢总结**

> 服务端维护了所有 Actor 的真实状态，客户端通过 `bReplicates` 获取副本；
>  客户端只能控制 **它被授权控制的 Actor**，控制是通过调用 `Server RPC` 来请求服务端执行操作；
>  服务端再将操作结果通过网络复制（Replicated 或 Multicast）同步给所有客户端。